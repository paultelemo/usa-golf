<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Can you win the USA jacket?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
</head>
<body>

<center>
  <div id="page">
    <h1>Can you win the USA jacket?</h1>
    <hr>

    <div style="margin:8px 0;">
      <button id="resetBtn">Reset Ball</button>
      <span class="small" id="strokeLabel" style="margin-left:10px;">Strokes: 0</span>
      <span class="small" id="statusLabel" style="margin-left:14px;"></span>
    </div>

    <canvas id="course" width="640" height="360"
            style="border:1px solid #666; background:#cfe8c4; max-width:100%;"></canvas>

    <hr>
    <p class="small">
      <a href="./index.html">Main Event</a> |
      <a href="./team.html">Team Event</a> |
      <a href="./game.html">Can you win the USA jacket?</a> |
      <a href="./gallery.html"><b>Gallery</b></a>
    </p>
  </div>
</center>

<script>
(function(){
  const canvas = document.getElementById('course');
  const ctx = canvas.getContext('2d');

  // Course dimensions
  const W = canvas.width;
  const H = canvas.height;

  // Hole settings
  const hole = { x: W - 120, y: H/2, r: 14 };

  // Ball settings
  const ball = { x: 120, y: H/2, r: 7, vx: 0, vy: 0 };

  // Physics
  const friction = 0.985;     // velocity decay
  const wallBounce = 0.85;    // energy retained after a wall bounce
  const speedCap = 12;        // max initial speed
  const stopEps = 0.05;       // threshold to consider stopped

  // State
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let hasShot = false;        // ONE shot only
  let outcome = null;         // 'win' | 'lose' | null
  let strokes = 0;

  const strokeLabel = document.getElementById('strokeLabel');
  const statusLabel = document.getElementById('statusLabel');
  const resetBtn = document.getElementById('resetBtn');
  resetBtn.addEventListener('click', resetBall);

  function resetBall(){
    ball.x = 120; ball.y = H/2;
    ball.vx = 0; ball.vy = 0;
    strokes = 0;
    hasShot = false;
    outcome = null;
    statusLabel.textContent = '';
    strokeLabel.textContent = 'Strokes: ' + strokes;
  }

  // Mouse helpers
  function getMousePos(evt){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top)  * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener('mousedown', (e) => {
    if (outcome) return;           // game over
    if (hasShot) return;           // only one shot allowed
    // only allow shot if ball is stopped
    if (Math.hypot(ball.vx, ball.vy) < 0.2) {
      isDragging = true;
      dragStart = getMousePos(e);
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!isDragging || outcome || hasShot) return;
    const end = getMousePos(e);

    // Only shoot if mouse started near the ball
    if (Math.hypot(dragStart.x - ball.x, dragStart.y - ball.y) <= ball.r + 16) {
      let vx = (dragStart.x - end.x) * 0.08;
      let vy = (dragStart.y - end.y) * 0.08;
      // Cap speed
      const sp = Math.hypot(vx, vy);
      if (sp > speedCap) {
        vx *= speedCap / sp;
        vy *= speedCap / sp;
      }
      ball.vx = vx; ball.vy = vy;
      strokes = 1;
      strokeLabel.textContent = 'Strokes: 1';
      hasShot = true;             // ONE shot taken
    }
    isDragging = false;
  });

  function update(){
    if (outcome) return;

    // Move
    ball.x += ball.vx;
    ball.y += ball.vy;

    // Friction
    ball.vx *= friction;
    ball.vy *= friction;

    // Walls
    if (ball.x - ball.r < 10) { ball.x = 10 + ball.r; ball.vx = -ball.vx * wallBounce; }
    if (ball.x + ball.r > W - 10) { ball.x = W - 10 - ball.r; ball.vx = -ball.vx * wallBounce; }
    if (ball.y - ball.r < 10) { ball.y = 10 + ball.r; ball.vy = -ball.vy * wallBounce; }
    if (ball.y + ball.r > H - 10) { ball.y = H - 10 - ball.r; ball.vy = -ball.vy * wallBounce; }

    // Check hole capture (snap if slow enough within hole)
    const d = Math.hypot(ball.x - hole.x, ball.y - hole.y);
    const speed = Math.hypot(ball.vx, ball.vy);
    if (d < hole.r - 1 && speed < 0.6) {
      // Holed
      ball.x = hole.x; ball.y = hole.y;
      ball.vx = 0; ball.vy = 0;
      outcome = 'win';
      statusLabel.textContent = 'YOU WON';
    }

    // If player has taken the single shot and the ball fully stops without holing â†’ lose
    if (!outcome && hasShot && speed < stopEps) {
      ball.vx = 0; ball.vy = 0;
      outcome = 'lose';
      statusLabel.textContent = 'YOU LOSE';
    }
  }

  // ----- Drawing helpers -----
  function drawUSFlag(x, y, w, h){
    // Background (white)
    ctx.fillStyle = '#fff';
    ctx.fillRect(x, y, w, h);
    // Red stripes
    ctx.fillStyle = '#b22234';
    const stripeH = h / 13;
    for (let i = 0; i < 13; i += 2) {
      ctx.fillRect(x, y + i * stripeH, w, stripeH);
    }
    // Blue canton
    const cantonW = w * 0.4;
    const cantonH = stripeH * 7;
    ctx.fillStyle = '#3c3b6e';
    ctx.fillRect(x, y, cantonW, cantonH);
    // Simple white dots as "stars"
    ctx.fillStyle = '#fff';
    const rows = 5, cols = 6;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const sx = x + (c + 0.6) * (cantonW / cols);
        const sy = y + (r + 0.6) * (cantonH / rows);
        ctx.beginPath();
        ctx.arc(sx, sy, Math.min(w,h) * 0.006, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Helper: 5-point star
function drawStar(ctx, cx, cy, outerR, innerR, fillStyle){
  ctx.save();
  ctx.beginPath();
  for (let i = 0; i < 10; i++) {
    const a = -Math.PI/2 + i * (Math.PI/5);
    const r = (i % 2 === 0) ? outerR : innerR;
    const x = cx + r * Math.cos(a);
    const y = cy + r * Math.sin(a);
    i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.fillStyle = fillStyle;
  ctx.fill();
  ctx.restore();
}

// Improved USSR flag
function drawSovietFlag(x, y, w, h){
  const GOLD = '#ffd700';
  const RED  = '#cc0000';

  // Red field
  ctx.fillStyle = RED;
  ctx.fillRect(x, y, w, h);

  // Emblem layout (scale relative to flag size, placed near hoist)
  const S = Math.min(w, h);
  const ex = x + w * 0.18;      // emblem anchor (left-ish)
  const ey = y + h * 0.30;      // emblem anchor (upper third)

  // --- Sickle (crescent) using two circles: big gold circle minus smaller red offset ---
  const R_outer = 0.24 * S;     // outer (gold) radius
  const R_inner = 0.19 * S;     // carving (red) radius
  const cresX   = ex + 0.14 * S;
  const cresY   = ey + 0.02 * S;

  // Gold disk
  ctx.beginPath();
  ctx.arc(cresX, cresY, R_outer, 0, Math.PI * 2);
  ctx.fillStyle = GOLD;
  ctx.fill();

  // Carve inner crescent with red disk (offset to create crescent shape)
  ctx.beginPath();
  ctx.arc(cresX + 0.10 * S, cresY - 0.06 * S, R_inner, 0, Math.PI * 2);
  ctx.fillStyle = RED;
  ctx.fill();

  // --- Hammer (handle + head), rotated slightly ---
  // Handle
  ctx.save();
  ctx.translate(ex + 0.20 * S, ey + 0.14 * S);
  ctx.rotate(-25 * Math.PI / 180);
  ctx.fillStyle = GOLD;
  ctx.fillRect(-0.015 * S, -0.02 * S, 0.03 * S, 0.36 * S); // thin vertical-ish bar
  ctx.restore();

  // Head (rectangle) + face (small square)
  ctx.save();
  ctx.translate(ex + 0.14 * S, ey - 0.02 * S);
  ctx.rotate(-25 * Math.PI / 180);
  ctx.fillStyle = GOLD;
  ctx.fillRect(0, 0, 0.18 * S, 0.055 * S);                  // hammer head
  ctx.fillRect(-0.03 * S, 0.01 * S, 0.045 * S, 0.045 * S);  // hammer face (square)
  ctx.restore();

  // --- Star above the emblem ---
  const starCX = ex + 0.12 * S;
  const starCY = ey - 0.20 * S;
  drawStar(ctx, starCX, starCY, 0.07 * S, 0.03 * S, GOLD);

  // Optional: slight gold outline for emblem crispness (subtle)
  ctx.save();
  ctx.strokeStyle = GOLD;
  ctx.lineWidth = Math.max(1, S * 0.004);
  // outline the crescent outer curve
  ctx.beginPath();
  ctx.arc(cresX, cresY, R_outer, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();
}

  function drawOverlay(){
    if (!outcome) return;

    // Dim background
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(0, 0, W, H);

    const fw = Math.min(W*0.5, 360);
    const fh = Math.min(H*0.35, 200);
    const fx = (W - fw)/2;
    const fy = (H - fh)/2;

    // Flag + text panel
    ctx.fillStyle = '#f4faef';
    ctx.fillRect(fx, fy, fw, fh);
    ctx.strokeStyle = '#334';
    ctx.lineWidth = 2;
    ctx.strokeRect(fx, fy, fw, fh);

    // Draw flag
    const pad = 12;
    const flagW = fw - pad*2;
    const flagH = fh * 0.55;
    if (outcome === 'win') drawUSFlag(fx + pad, fy + pad, flagW, flagH);
    else drawSovietFlag(fx + pad, fy + pad, flagW, flagH);

    // Text
    ctx.fillStyle = outcome === 'win' ? '#063' : '#800';
    ctx.font = 'bold 28px "Times New Roman", serif';
    ctx.textAlign = 'center';
    ctx.fillText(outcome === 'win' ? 'YOU WON' : 'YOU LOSE', W/2, fy + flagH + pad + 34);
  }

  function draw(){
    // Clear
    ctx.clearRect(0, 0, W, H);

    // Walls
    ctx.strokeStyle = '#335533';
    ctx.lineWidth = 2;
    ctx.strokeRect(10, 10, W - 20, H - 20);

    // Simple obstacle
    ctx.fillStyle = '#b6d8a8';
    ctx.fillRect(W/2 - 60, H/2 - 8, 120, 16);

    // Hole
    ctx.beginPath();
    ctx.fillStyle = '#333';
    ctx.arc(hole.x, hole.y, hole.r, 0, Math.PI * 2);
    ctx.fill();

    // Ball
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#666';
    ctx.stroke();

    // Aim line (allowed only before first shot)
    if (isDragging && !hasShot && !outcome) {
      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      ctx.moveTo(ball.x, ball.y);
      ctx.lineTo(dragStart.x, dragStart.y);
      ctx.strokeStyle = '#224422';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.setLineDash([]);
    }

    drawOverlay();
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }

  resetBall();
  loop();
})();
</script>

</body>
</html>
