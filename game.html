<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Can you win the USA jacket?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <style>
    canvas { touch-action: none; } /* prevent page scroll while dragging */
  </style>
</head>
<body>

<center>
  <div id="page">
    <h1>Can you win the USA jacket?</h1>
    <hr>

    <div style="margin:8px 0;">
      <button id="resetBtn">Reset Ball</button>
      <span class="small" id="strokeLabel" style="margin-left:10px;">Strokes: 0</span>
      <span class="small" id="statusLabel" style="margin-left:14px;"></span>
    </div>

    <canvas id="course" width="640" height="360"
            style="border:1px solid #666; background:#cfe8c4; max-width:100%;"></canvas>

    <hr>
    <p class="small">
      <a href="./index.html">Main Event</a> |
      <a href="./team.html">Team Event</a> |
      <a href="./game.html">Can you win the USA jacket?</a> |
      <a href="./gallery.html"><b>Gallery</b></a>
    </p>
  </div>
</center>

<script>
(function(){
  const canvas = document.getElementById('course');
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;

  const hole = { x: W - 120, y: H / 2, r: 14 };
  const ball = { x: 120, y: H / 2, r: 7, vx: 0, vy: 0 };

  const friction = 0.985, wallBounce = 0.85, speedCap = 12, stopEps = 0.05;
  let isDragging = false, dragStart = {x:0,y:0}, pointerPos = null;
  let hasShot = false, outcome = null, strokes = 0;

  const strokeLabel = document.getElementById('strokeLabel');
  const statusLabel = document.getElementById('statusLabel');
  document.getElementById('resetBtn').addEventListener('click', resetBall);

  function resetBall(){
    ball.x = 120; ball.y = H/2; ball.vx = ball.vy = 0;
    strokes = 0; hasShot = false; outcome = null;
    statusLabel.textContent = '';
    strokeLabel.textContent = 'Strokes: 0';
  }

  function getPointerPos(evt){
    const rect = canvas.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) * (canvas.width / rect.width),
      y: (evt.clientY - rect.top) * (canvas.height / rect.height)
    };
  }

  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // === Pointer event handlers (works on phone + mouse) ===
  canvas.addEventListener('pointerdown', (e) => {
    if (outcome || hasShot) return;
    if (Math.hypot(ball.vx, ball.vy) >= 0.2) return;
    const p = getPointerPos(e);
    pointerPos = p;
    if (Math.hypot(p.x - ball.x, p.y - ball.y) <= ball.r + 16) {
      isDragging = true;
      dragStart = p;
      canvas.setPointerCapture(e.pointerId);
    }
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!isDragging) return;
    pointerPos = getPointerPos(e);
  });

  canvas.addEventListener('pointerup', (e) => {
    if (!isDragging || outcome || hasShot) return;
    const end = pointerPos || getPointerPos(e);
    let vx = (dragStart.x - end.x) * 0.08;
    let vy = (dragStart.y - end.y) * 0.08;
    const sp = Math.hypot(vx, vy);
    if (sp > speedCap) { vx *= speedCap / sp; vy *= speedCap / sp; }
    ball.vx = vx; ball.vy = vy;
    strokes = 1; hasShot = true;
    strokeLabel.textContent = 'Strokes: 1';
    isDragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  canvas.addEventListener('pointercancel', (e) => {
    isDragging = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  // === Game logic ===
  function update(){
    if (outcome) return;

    ball.x += ball.vx; ball.y += ball.vy;
    ball.vx *= friction; ball.vy *= friction;

    if (ball.x - ball.r < 10) { ball.x = 10 + ball.r; ball.vx = -ball.vx * wallBounce; }
    if (ball.x + ball.r > W - 10) { ball.x = W - 10 - ball.r; ball.vx = -ball.vx * wallBounce; }
    if (ball.y - ball.r < 10) { ball.y = 10 + ball.r; ball.vy = -ball.vy * wallBounce; }
    if (ball.y + ball.r > H - 10) { ball.y = H - 10 - ball.r; ball.vy = -ball.vy * wallBounce; }

    const d = Math.hypot(ball.x - hole.x, ball.y - hole.y);
    const speed = Math.hypot(ball.vx, ball.vy);
    if (d < hole.r - 1 && speed < 0.6) {
      outcome = 'win';
      ball.x = hole.x; ball.y = hole.y; ball.vx = ball.vy = 0;
      statusLabel.textContent = 'YOU WON';
    }
    if (!outcome && hasShot && speed < stopEps) {
      outcome = 'lose';
      ball.vx = ball.vy = 0;
      statusLabel.textContent = 'YOU LOSE';
    }
  }

  // === Flag drawing ===
  function drawUSFlag(x,y,w,h){
    ctx.fillStyle='#fff';ctx.fillRect(x,y,w,h);
    ctx.fillStyle='#b22234';const stripe=h/13;
    for(let i=0;i<13;i+=2)ctx.fillRect(x,y+i*stripe,w,stripe);
    const cw=w*0.4,ch=stripe*7;ctx.fillStyle='#3c3b6e';ctx.fillRect(x,y,cw,ch);
    ctx.fillStyle='#fff';for(let r=0;r<5;r++)for(let c=0;c<6;c++){
      const sx=x+(c+0.6)*(cw/6),sy=y+(r+0.6)*(ch/5);
      ctx.beginPath();ctx.arc(sx,sy,Math.min(w,h)*0.006,0,2*Math.PI);ctx.fill();
    }
  }
  function drawStar(cx,cy,outerR,innerR,fill){
    ctx.beginPath();
    for(let i=0;i<10;i++){
      const a=-Math.PI/2+i*(Math.PI/5);
      const r=i%2===0?outerR:innerR;
      const x=cx+r*Math.cos(a),y=cy+r*Math.sin(a);
      i?ctx.lineTo(x,y):ctx.moveTo(x,y);
    }
    ctx.closePath();ctx.fillStyle=fill;ctx.fill();
  }
  function drawSovietFlag(x,y,w,h){
    const GOLD='#ffd700',RED='#cc0000';
    ctx.fillStyle=RED;ctx.fillRect(x,y,w,h);
    const S=Math.min(w,h),ex=x+w*0.18,ey=y+h*0.3;
    const R_outer=0.24*S,R_inner=0.19*S,cx=ex+0.14*S,cy=ey+0.02*S;
    ctx.beginPath();ctx.arc(cx,cy,R_outer,0,2*Math.PI);ctx.fillStyle=GOLD;ctx.fill();
    ctx.beginPath();ctx.arc(cx+0.1*S,cy-0.06*S,R_inner,0,2*Math.PI);ctx.fillStyle=RED;ctx.fill();
    ctx.save();ctx.translate(ex+0.2*S,ey+0.14*S);ctx.rotate(-25*Math.PI/180);
    ctx.fillStyle=GOLD;ctx.fillRect(-0.015*S,-0.02*S,0.03*S,0.36*S);ctx.restore();
    ctx.save();ctx.translate(ex+0.14*S,ey-0.02*S);ctx.rotate(-25*Math.PI/180);
    ctx.fillStyle=GOLD;ctx.fillRect(0,0,0.18*S,0.055*S);ctx.fillRect(-0.03*S,0.01*S,0.045*S,0.045*S);ctx.restore();
    drawStar(ex+0.12*S,ey-0.2*S,0.07*S,0.03*S,GOLD);
  }

  function drawOverlay(){
    if(!outcome)return;
    ctx.fillStyle='rgba(0,0,0,0.35)';ctx.fillRect(0,0,W,H);
    const fw=Math.min(W*0.5,360),fh=Math.min(H*0.35,200);
    const fx=(W-fw)/2,fy=(H-fh)/2;
    ctx.fillStyle='#f4faef';ctx.fillRect(fx,fy,fw,fh);
    ctx.strokeStyle='#334';ctx.lineWidth=2;ctx.strokeRect(fx,fy,fw,fh);
    const pad=12,flagW=fw-pad*2,flagH=fh*0.55;
    if(outcome==='win')drawUSFlag(fx+pad,fy+pad,flagW,flagH);
    else drawSovietFlag(fx+pad,fy+pad,flagW,flagH);
    ctx.fillStyle=outcome==='win'?'#063':'#800';
    ctx.font='bold 28px "Times New Roman",serif';
    ctx.textAlign='center';
    ctx.fillText(outcome==='win'?'YOU WON':'YOU LOSE',W/2,fy+flagH+pad+34);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.strokeStyle='#335533';ctx.lineWidth=2;ctx.strokeRect(10,10,W-20,H-20);
    ctx.fillStyle='#b6d8a8';ctx.fillRect(W/2-60,H/2-8,120,16);
    ctx.beginPath();ctx.fillStyle='#333';ctx.arc(hole.x,hole.y,hole.r,0,2*Math.PI);ctx.fill();
    ctx.beginPath();ctx.fillStyle='#fff';ctx.arc(ball.x,ball.y,ball.r,0,2*Math.PI);ctx.fill();ctx.strokeStyle='#666';ctx.stroke();

    if(isDragging&&!hasShot&&!outcome&&pointerPos){
      ctx.beginPath();ctx.setLineDash([5,5]);
      ctx.moveTo(ball.x,ball.y);ctx.lineTo(pointerPos.x,pointerPos.y);
      ctx.strokeStyle='#224422';ctx.lineWidth=1.5;ctx.stroke();ctx.setLineDash([]);
    }
    drawOverlay();
  }

  function loop(){ update(); draw(); requestAnimationFrame(loop); }
  resetBall(); loop();
})();
</script>

</body>
</html>
